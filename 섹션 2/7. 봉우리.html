<html>
<head>
    <meta charset="UTF-8">
    <title>제목</title>
</head>
<style>
    .container {
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        width: 100vw;
    }

    .pb-1 {
        padding-bottom: 3vh;
    }

    .title {
        width: 100vw;
        text-align: center;
    }
    .title h1{
        font-size: 32px;
    }

    .title span{
        font-size: 24px;
    }

    .description {
        width: 100vw;
        text-align: center;
    }

    .description h1 {
        font-size: 20px;
    }

    .description span {
        font-size: 16px;
    }

    .point::before {
        content: "*";

    }

</style>
<body>
<pre>
지도 정보가 N*N 격자판에 주어집니다. 각 격자에는 그 지역의 높이가 쓰여있습니다. 각 격자
판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역입니다. 봉우리 지역이 몇 개
있는 지 알아내는 프로그램을 작성하세요.
격자의 가장자리는 0으로 초기화 되었다고 가정한다.
만약 N=5 이고, 격자판의 숫자가 다음과 같다면 봉우리의 개수는 10개입니다.

0 0 0 0 0 0 0
0 5 3 7 2 3 0
0 3 7 1 6 1 0
0 7 2 5 3 4 0
0 4 3 6 4 1 0
0 8 7 3 5 2 0
0 0 0 0 0 0 0


▣ 입력설명
첫 줄에 자연수 N이 주어진다.(1<=N<=50)
두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다. 각 자연수는 100을 넘지 않는
다.

▣ 출력설명
봉우리의 개수를 출력하세요.

▣ 입력예제 1
5
5 3 7 2 3
3 7 1 6 1
7 2 5 3 4
4 3 6 4 1
8 7 3 5 2

▣ 출력예제 1
10
</pre>

<div class="description pb-1">
    <h1 class="point">
        Tip
    </h1>
    <span>
        왜 가장자리를 0으로 주었는가?
        과연 가장자리를 0으로 주지 않았다면 문제를 어떻게 풀지 고민한다면, 정답을 알 수 있다.
        0을 주지 않았을 때 스스로 저 자리에 0을 붙일 수 있는지 고민해본다.
    </span>
</div>

<script>

    function solution(s){
        let isTop = [
            [false, false, false, false, false],
            [false, false, false, false, false],
            [false, false, false, false, false],
            [false, false, false, false, false],
            [false, false, false, false, false]
        ];


        let result = 0;


        // 4개의 방향을 담을 변수
        let dx=[-1, 0, 1, 0];
        let dy=[0, 1, 0, -1];


        for (let i=1; i<s.length-1; i++) {
            for (let j=1; j<s[i].length-1; j++) {
                let target = s[i][j];


                let flag = true;
                for (let t=0; t<4; t++) {
                    // console.log(i + dy[t], j + dx[t], s[i + dy[t]][j + dx[t]]);

                    // 4 방향중 작은 것이 하나라도 있으면
                    if (s[i + dy[t]][j + dx[t]] >= target) {
                        flag = false;
                    }
                }

                if (flag) {
                    result++;
                }
            }
        }

        return result;
    }


    let arr = [
        [0, 0, 0, 0, 0, 0, 0],
        [0, 5, 3, 7, 2, 3, 0],
        [0, 3, 7, 1, 6, 1, 0],
        [0, 7, 2, 5, 3, 4, 0],
        [0, 4, 3, 6, 4, 1, 0],
        [0, 8, 7, 3, 5, 2, 0],
        [0, 0, 0, 0, 0, 0, 0]
        ];

    console.log(solution(arr))


</script>
</body>
</html>
