<html>
<head>
    <meta charSet="UTF-8">
    <title>제목</title>
</head>
<style>
    .container {
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        width: 100vw;
    }

    .pb-1 {
        padding-bottom: 3vh;
    }

    .title {
        width: 100vw;
        text-align: center;
    }

    .title h1 {
        font-size: 32px;
    }

    .title span {
        font-size: 24px;
    }

    .description {
        width: 100vw;
        text-align: center;
    }

    .description h1 {
        font-size: 20px;
    }

    .description span {
        font-size: 16px;
    }

    .point::before {
        content: "*";

    }

</style>
<body>
<pre>
1부터 N까지 번호가 적힌 구슬이 있습니다. 이 중 M개를 뽑는 방법의 수를 출력하는 프로그
램을 작성하세요.


▣ 입력설명
첫 번째 줄에 자연수 N(3<=N<=10)과 M(2<=M<=N) 이 주어집니다.

▣ 출력설명
첫 번째 줄에 결과를 출력합니다. 맨 마지막 총 경우의 수를 출력합니다.
출력순서는 사전순으로 오름차순으로 출력합니다.

▣ 입력예제 1
4 2

▣ 출력예제 1
1 2
1 3
1 4
2 3
2 4
3 4
6
</pre>

<div className="description pb-1">
    <h1 className="point">
        Tip
    </h1>
    <span>
        뽑아 나열하는 경우와 다르게 순서는 상관이 뽑는 방법
        만약, 1 ~ n 의 카드중 2개를 뽑는다고 가정을 하면 아래와 같이 뽑을 수 있다.
        for (let i=1; i<=n; i++) {
            for (let j=i+1; j<=n; j++) {
                // 이렇게 뽑으면 카드를 중복하지 않고, 순서에 상관없이 뽑을 수 있다.
                let first = i, second = j;
            }
        }

    </span>
</div>

<script>
    function solution(n, r) {

        let arr = Array.from({length: r}, () => 0);
        let result = [];
        function DFS(m, before) {
            if (m >= r) {
                result.push(arr.slice());
                return;
            }

            // 카드가 n까지 있다는 사실을 잊지 말기
            for (let i=before; i<=n; i++) {
                // 탐색한 순서에 카드를 넣기
                arr[m] = i;
                DFS(m+1, i+1);
            }
        }

        // 0회차 1 번 카드부터 탐색
        DFS(0, 1);

        return result;
    }


    console.log(solution(4, 2));
    console.log(solution(4, 2).length);



</script>
</body>
</html>
