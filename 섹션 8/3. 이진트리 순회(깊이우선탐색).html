<html>
<head>
    <meta charSet="UTF-8">
    <title>제목</title>
</head>
<style>
    .container {
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        width: 100vw;
    }

    .pb-1 {
        padding-bottom: 3vh;
    }

    .title {
        width: 100vw;
        text-align: center;
    }

    .title h1 {
        font-size: 32px;
    }

    .title span {
        font-size: 24px;
    }

    .description {
        width: 100vw;
        text-align: center;
    }

    .description h1 {
        font-size: 20px;
    }

    .description span {
        font-size: 16px;
    }

    .point::before {
        content: "*";

    }

</style>
<body>
<pre>
아래 그림과 같은 이진트리를 전위순회와 후위순회를 연습해보세요.

<img src="./img/이진트리.png" />

전위순회 출력 : 1 2 4 5 3 6 7
중위순회 출력 : 4 2 5 1 6 3 7
후위순회 출력 : 4 5 2 6 7 3 1
</pre>

<div className="description pb-1">
    <h1 className="point">
        Tip
    </h1>
    <span>
        전위순위 : 부모 - 왼쪽자식 - 오른쪽자식 순서로 탐색
        중위순위 : 왼쪽자식 - 부모 - 오른쪽자식 순서로 탐색
        후위순위 : 왼쪽자식 - 오른쪽자식 - 부모 순서로 탐색
    </span>
</div>

<script>

    /**
     * 전위, 중위, 후위 순서로 탐색을 하려면,
     * 왼쪽 오른쪽 자식과 같이 방향을 정의하고 있어야 하는데,
     * 노드 사이에 방향성을 가지는 자료구조에는 힙과 트리가 있다.
     *
     * 이 때, 트리의 경우 노드를 사용해서 그래프를 연결하고
     * 힙은 배열을 사용해서, 연결 관계를 표현한다. (배열의 인덱스를 가지고)
     *
     * 따라서 이 탐색은 힙을 탐색하는 방법이라고 할 수 있다.
     *
     * (부모 인덱스) * 2 + 1는 왼쪽 자식의 인덱스이고
     * (부모 인덱스) * 2 + 2는 오른쪽 자식의 인덱스이다.
     * */
    let arr = [1,2,3,4,5,6,7];

    // 전위 순위 탐색
    function solution(graph, size) {
        function DFS(n) {
            if (n >= size) return;

            // n번 인덱스를 탐색한다.
            console.log(graph[n]);
            // 왼쪽 탐색
            DFS(2 * n + 1);
            // 오른쪽 탐색
            DFS(2 * n + 2);
        }

        DFS(0);
    }

    // 중위 순위 탐색
    function solution1(graph, size) {
        function DFS(n) {
            if (n >= size) return;


            // 왼쪽 탐색
            DFS(2 * n + 1);

            // n번 인덱스를 탐색한다.
            console.log(graph[n]);

            // 오른쪽 탐색 => 우측 자식을 가장 늦게 탐색
            DFS(2 * n + 2);
        }

        DFS(0);
    }

    // 후위 순위 탐색
    function solution2(graph, size) {
        function DFS(n) {
            if (n >= size) return;


            // 왼쪽 탐색
            DFS(2 * n + 1);

            // 오른쪽 탐색
            DFS(2 * n + 2);

            // n번 인덱스를 탐색한다. => 부모를 가장 늦게 탐색
            console.log(graph[n]);
        }

        DFS(0);
    }

    solution1(arr, arr.length);

</script>
</body>
</html>
